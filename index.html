<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fantasy Runner Stage</title>
<style>
body{margin:0;overflow:hidden;background:black;}
canvas{display:block;margin:0 auto;background:#87ceeb;}
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

const WIDTH=800;
const HEIGHT=450;

canvas.width=WIDTH;
canvas.height=HEIGHT;
canvas.style.width="100vw";
canvas.style.height="100vh";

let state="intro";
let health=3;
let gameSpeed=4;

let obstacles=[];
let obstacleCount=0;
let spawnTimer=0;
let spawnDelay=60;

let invincible=false;
let invTimer=0;

/* ================= PLAYER ================= */

class Player{
 constructor(){
  this.x=150;
  this.width=40;
  this.height=60;
  this.y=HEIGHT-40-this.height;
  this.vy=0;

  this.gravity=0.8;
  this.maxFall=15;
  this.jumpCount=0;
 }

 update(){
  this.vy+=this.gravity;
  if(this.vy>this.maxFall) this.vy=this.maxFall;

  this.y+=this.vy;

  if(this.y+this.height>=HEIGHT-40){
   this.y=HEIGHT-40-this.height;
   this.vy=0;
   this.jumpCount=0;
  }
 }

 jump(){
  if(this.jumpCount<2){
   this.vy=-17;
   this.jumpCount++;
  }
 }

 draw(){

  if(invincible) ctx.globalAlpha=0.6;

  // 그림자
  ctx.fillStyle="rgba(0,0,0,0.3)";
  ctx.beginPath();
  ctx.ellipse(this.x+20,HEIGHT-30,20,8,0,0,Math.PI*2);
  ctx.fill();

  // 몸통
  ctx.fillStyle="#3498db";
  ctx.fillRect(this.x+10,this.y+25,20,25);

  // 머리
  ctx.fillStyle="#ffcc99";
  ctx.beginPath();
  ctx.arc(this.x+20,this.y+15,15,0,Math.PI*2);
  ctx.fill();

  // 눈
  ctx.fillStyle="black";
  ctx.beginPath();
  ctx.arc(this.x+15,this.y+12,2,0,Math.PI*2);
  ctx.arc(this.x+25,this.y+12,2,0,Math.PI*2);
  ctx.fill();

  ctx.globalAlpha=1;
 }
}

let player=new Player();

/* ================= OBSTACLE ================= */

class Obstacle{
 constructor(){
  this.width=40;
  this.height=50;
  this.x=WIDTH+Math.random()*200+150;
  this.type = obstacleCount<5 ? "tree" : "monster";
  obstacleCount++;
 }

 update(){ this.x-=gameSpeed; }

 draw(){

  if(this.type==="tree"){
   // 줄기
   ctx.fillStyle="#8B4513";
   ctx.fillRect(this.x+15,HEIGHT-40-30,10,30);

   // 잎
   ctx.fillStyle="green";
   ctx.beginPath();
   ctx.moveTo(this.x+20,HEIGHT-120);
   ctx.lineTo(this.x,this.y+20);
   ctx.lineTo(this.x+40,this.y+20);
   ctx.closePath();
   ctx.fill();
  }
  else{
   // 괴물
   ctx.fillStyle="purple";
   ctx.beginPath();
   ctx.arc(this.x+20,HEIGHT-60,20,0,Math.PI*2);
   ctx.fill();

   ctx.fillStyle="white";
   ctx.beginPath();
   ctx.arc(this.x+14,HEIGHT-65,5,0,Math.PI*2);
   ctx.arc(this.x+26,HEIGHT-65,5,0,Math.PI*2);
   ctx.fill();
  }
 }

 get y(){
  return HEIGHT-40-this.height;
 }
}

/* ================= INPUT ================= */

canvas.addEventListener("touchend",()=>{
 if(state==="intro"){ startGame(); return; }
 if(state==="play"){ player.jump(); }
 if(state==="gameover"){ startGame(); }
});

document.addEventListener("keydown",e=>{
 if(e.code==="Space"){
  if(state==="intro"){ startGame(); return; }
  if(state==="play"){ player.jump(); }
  if(state==="gameover"){ startGame(); }
 }
});

/* ================= GAME CONTROL ================= */

function startGame(){
 health=3;
 obstacles=[];
 obstacleCount=0;
 spawnTimer=0;
 spawnDelay=30;
 invincible=false;
 state="play";
}

/* ================= UPDATE ================= */

function update(){
 if(state!=="play") return;

 player.update();

 if(spawnDelay>0){
  spawnDelay--;
 }else{
  spawnTimer++;
  if(spawnTimer>80){
   obstacles.push(new Obstacle());
   spawnTimer=0;
  }
 }

 obstacles.forEach(o=>o.update());

 obstacles.forEach(o=>{
  if(player.x<o.x+40 &&
     player.x+player.width>o.x &&
     player.y<o.y+50 &&
     player.y+player.height>o.y &&
     !invincible){

   health--;
   invincible=true;
   invTimer=60;

   if(health<=0) state="gameover";
  }
 });

 obstacles=obstacles.filter(o=>o.x>-100);

 if(invincible){
  invTimer--;
  if(invTimer<=0) invincible=false;
 }
}

/* ================= DRAW ================= */

function draw(){
 ctx.clearRect(0,0,WIDTH,HEIGHT);

 if(state==="intro"){
  ctx.fillStyle="black";
  ctx.fillRect(0,0,WIDTH,HEIGHT);
  ctx.fillStyle="white";
  ctx.font="30px Arial";
  ctx.fillText("TAP OR SPACE TO START",200,200);
  return;
 }

 if(state==="gameover"){
  ctx.fillStyle="black";
  ctx.fillRect(0,0,WIDTH,HEIGHT);
  ctx.fillStyle="red";
  ctx.font="40px Arial";
  ctx.fillText("GAME OVER",250,200);
  ctx.fillStyle="white";
  ctx.font="20px Arial";
  ctx.fillText("Tap or Space to Restart",230,240);
  return;
 }

 ctx.fillStyle="#87ceeb";
 ctx.fillRect(0,0,WIDTH,HEIGHT);

 ctx.fillStyle="green";
 ctx.fillRect(0,HEIGHT-40,WIDTH,40);

 obstacles.forEach(o=>o.draw());
 player.draw();

 for(let i=0;i<health;i++){
  ctx.fillStyle="red";
  ctx.beginPath();
  ctx.arc(700+i*25,25,8,0,Math.PI*2);
  ctx.fill();
 }
}

/* ================= LOOP ================= */

function loop(){
 update();
 draw();
 requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
